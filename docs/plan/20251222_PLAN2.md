# プランニングドキュメント：メモ帳AI（Gemini）— 文章生成/編集（選択範囲対応）

**作成日**: 2025-12-22
**バージョン**: 1.1
**ステータス**: 完了（ユーザー動作確認済み）
**前バージョンからの変更**: カスタムプロンプト（常に適用）の設定を追加

※初めて作業に取り掛かる場合は、必ずこのプランドキュメントと別にある要件定義書（`docs/requirement.md`）にも目を通してください。

---

# 進捗状況

## ⚡ クイックリファレンス

**目的**: メモ欄の文章を、AIに「生成/修正/要約/整形」させて素早く編集できるようにする  
**対象**: メモパネル（content script）/ 背景（service worker）/ UI（モーダル）/ 設定（APIキー/カスタムプロンプト）  
**非対象**: サーバーを立ててプロキシする方式、AI結果の自動保存ルール変更、同期仕様の変更

**完了条件（要点）**

- ヘッダーのアイコン群に **AIボタン** があり、押すとAIモーダルが開く
- AIモーダルで「指示」を入力 → 実行して本文へ反映できる（AI反映直後は Cmd/Ctrl+Z で戻せる）
- AIモーダルの歯車（⚙）から、**常に適用するプロンプト（カスタムプロンプト）** を設定できる
- 文字を選択している場合、AIはその **選択範囲** を認識し、既定で「選択範囲だけ置換」できる
- 選択がない場合、既定で「カーソル位置に挿入」（または全文置換を選べる）
- Gemini APIキーはUIから設定でき、**chrome.storage.local** に保存（同期ストレージには保存しない）

**現在地**: Phase 7 - 完了
**次のアクション**: なし（必要ならGeminiモデル名を調整）
**ブロッカー**: なし

- [x] Phase 0: 仕様確定（質問への回答）
- [x] Phase 1: APIキー管理（UI/保存/削除）
- [x] Phase 2: AIモーダルUI（指示入力/適用先/実行して反映）
- [x] Phase 3: 選択範囲の取得（左右ペイン対応）
- [x] Phase 4: Gemini呼び出し（background経由）
- [x] Phase 5: 適用ロジック（選択置換/挿入/全文置換）
- [x] Phase 6: 手動確認 + ドキュメント同期
- [x] Phase 7: カスタムプロンプト設定（歯車/保存/クリア/常に適用）

### 環境チェックリスト

- [ ] Gemini APIキー（ユーザー入力）を設定済み

### 重要なファイルパス（想定）

- UI（パネルHTML）: `src/content/panelTemplate.ts`
- イベント/結線: `src/content/content.ts`
- パネル操作: `src/content/panelActions.ts`
- 背景メッセージ処理: `src/background/background.ts`
- 型・MessageType: `src/types/index.ts`
- 保存（storage）: `src/utils/storage.ts` / `src/lib/chromeStorage.ts`
- Gemini API: `src/lib/gemini.ts`
- CSS: `src/styles/panel.css`

---

## 🔎 まず確認したいこと（最大3つ）

1) **選択がない時の既定**はどれが良いですか？  
   Aです（カーソル位置に挿入）

2) AIは **プレビューなしで即反映**し、AI反映直後は **Cmd/Ctrl+Zで戻す** 方針でOKですか？  
   OKです。

3) APIキーは、まずは **端末ローカル保存のみ（chrome.storage.local）** で進めてOKですか？  
   OKです（`chrome.storage.local` に保存、同期しない）
  
---

# 実装内容

## 💭 主要な意思決定（案）

- **Gemini呼び出しは background（service worker）経由**に寄せる  
  - content script から直接 `fetch` せず、`chrome.runtime.sendMessage` で依頼する
- **選択範囲がある場合は選択置換が既定**（ただしUIで変更可能にする）
- **APIキーはユーザー自身のキーを入力**し、`chrome.storage.local` に保存（同期しない）
- **APIキーやプロンプト本文は console に出さない**（ログ流出を避ける）

---

## 要件概要（今回追加する動き）

### 目的

- メモの文章を、AIで「書く/直す/短くする/整える」作業を早くする。

### ユースケース例

- 選択範囲あり: 「この部分を簡潔にして」→ **選択部分だけ**書き換わる
- 選択範囲なし: 「TODOを箇条書きにして」→ **カーソル位置**に生成文を挿入（または全文置換）

### 対象範囲

- メモパネル内（左右スプリット含む）のテキストエリア
- AIボタン/AIモーダル
- Gemini APIキー/カスタムプロンプトの設定UI

### 非対象

- 自動で常にAIが提案する（常時補完）
- AI結果の自動保存のルール変更（保存ボタンや既存保存フローに従う）

---

## UI仕様（案）

### 1) ヘッダーにAIボタン追加

- 追加場所: 既存のアイコン群（例: `#auth-btn` の近く）
- 役割: AIモーダルを開く

### 2) AIモーダル

- 指示入力欄（例: 1〜3行のテキストエリア）
- 対象表示（現在の対象を明示）
  - 「選択範囲: あり/なし」
  - 選択中テキストのプレビュー（長い場合は一部）
- 歯車（⚙）から「AI設定」を開き、常に適用するプロンプトを保存/クリアできる
- 適用先の選択（選択範囲を置換 / カーソルに挿入 / 全文を置換）
- 実行して反映ボタン（実行中はdisabled）
- 閉じるボタン

---

## 選択範囲の扱い（textarea前提）

対象のメモ欄は `textarea`（`#memo-textarea-left/right`）なので、以下で実現できる。

- 取得: `selectionStart`, `selectionEnd`, `value.slice(start, end)`
- 追跡: `select` / `mouseup` / `keyup` などで更新
- スプリット対応: 左右それぞれの選択状態を保持し、**最後にフォーカスしたペイン**を対象にする

---

## Gemini呼び出し仕様（案）

### 方式

- content script → background にメッセージ送信
- background がGemini APIへ `fetch` して結果を返す

### 送る情報（最小）

- ユーザー指示（プロンプト）
- 対象テキスト
  - 選択範囲あり: 選択テキスト + 前後の少しの文脈（任意）
  - 選択範囲なし: 全文（長い場合は上限を決めて切る）
- 希望する適用モード（置換/挿入/全文）

### 返す情報（最小）

- 生成テキスト（プレーンテキスト）

※安定運用のため、余裕があれば「JSON形式で返す」等の**構造化**も検討（Phase 4で判断）。

---

## APIキー管理（セキュリティ方針の案）

### 結論（現時点の推奨）

- **ユーザー自身のGemini APIキーを入力**して使うなら、`chrome.storage.local` に保存する方式は「現実的」  
  （ただし、端末がマルウェア等に侵害された場合の保護まではできません）
- **拡張機能に開発者の共通キーを埋め込むのはNG**（拡張から抜かれて悪用されます）

### UI案（ユーザーアイコン👤のモーダル内に追加）

- 「AI（Gemini）」セクションを追加
  - APIキー入力（マスク表示）
  - 保存 / 削除
  - （任意）接続テストボタン

---

## 実装フェーズ（案）

### Phase 1: APIキー管理（UI/保存/削除）

- `docs/requirement.md` にAI設定の方針（保存場所/非同期）を追記（必要なら）
- APIキーを `chrome.storage.local` に保存できるようにする（キー名は要統一）
- 👤モーダルに入力欄を追加して保存/削除できるようにする

### Phase 2: AIモーダルUI

- `panelTemplate.ts` にAIボタン + AIモーダルHTMLを追加
- `panel.css` にモーダルの最低限スタイルを追加
- `content.ts` / `panelActions.ts` で開閉とUI更新を実装

### Phase 3: 選択範囲の取得（左右ペイン）

- 現在フォーカス中のペインを特定し、選択範囲を取得できるようにする
- AIモーダルに「選択あり/なし」を表示できるようにする

### Phase 4: Gemini呼び出し（background）

- `MessageType` とメッセージ型を追加
- backgroundでGemini APIを呼び出して結果を返す
- エラーハンドリング（キー未設定/HTTPエラー/タイムアウト）

### Phase 5: 適用ロジック

- 置換（選択範囲）: `value` の部分置換 + `setSelectionRange`
- 挿入（カーソル）: カーソル位置へ挿入 + カーソル移動
- 全文置換: `value = result`
- 適用後は `input` を発火して既存の自動保存・未保存フラグ更新に乗せる

### Phase 6: 手動確認 + ドキュメント同期

- 選択あり/なし、左右ペイン、下書き/通常メモ、保存/同期と干渉しないか確認
- `docs/requirement.md` にAI機能の仕様を追記（範囲/非対象/完了条件）

---

## リスクと対応策

- **APIキーの安全性**: クライアント内に「完全に安全な保存」はない → ローカル保存 + ログ出力禁止 + 削除導線を用意
- **選択範囲の取り違え**: 対象ペインをUIに明示（左/右、選択あり/なし）して事故を減らす
- **AIの出力が長すぎる/的外れ**: AI反映直後は Cmd/Ctrl+Z で戻せるようにする

---

## 完了条件（詳細）

- AIボタンからAIモーダルを開ける
- 指示→実行でGeminiから出力を取得できる
- 選択範囲がある場合、その範囲のみを置換できる
- 選択がない場合、カーソル位置に挿入（または指定した適用方法）できる
- APIキーを保存/削除でき、未設定時は分かりやすいエラーが出る

---

## 手動確認チェックリスト

- [ ] 👤 → Gemini APIキーを保存できる（保存後に「保存済み」になる）
- [ ] 🤖 → AIモーダルが開く（選択/対象ペインが表示される）
- [ ] 選択なし → 指示入力 → 実行して本文へ反映される
- [ ] AI反映直後に Cmd/Ctrl+Z で元に戻せる
- [ ] 選択なし → 適用先が「カーソルに挿入」になっている
- [ ] 選択あり → 指示入力 → 実行 → 適用先が「選択を置換」になっている
- [ ] スプリット右側を操作して選択 → 対象が「右」になる
- [ ] 適用で本文が変わり、保存/未保存の挙動が壊れていない
